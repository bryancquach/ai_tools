---

## **Code Analysis Prompt: Statistical & Mathematical Algorithm Discovery**

### **Objective**
Analyze a medium-sized library codebase (primarily Python/R, possibly C/C++, Rust, Java, Scala, Julia, Bash) to identify, document, and map all core statistical and mathematical algorithms. The analysis should reveal implementation techniques, dependency chains, and data flow through algorithmic components.

### **Context**
- **Codebase type**: Library for statistical/scientific computing or data science
- **Analysis method**: Static code analysis (no code execution)
- **Current knowledge level**: High-level architecture understood, but core algorithm details unknown
- **Purpose**: Learning implementation techniques, debugging support, and preparing for extensions

### **Required Deliverables**

1. **Mermaid.js flowcharts/diagrams** showing:
   - High-level library architecture
   - Dependency graphs for algorithmic components
   - Data flow through computational pipelines

2. **Markdown documentation** containing:
   - Overview of library architecture
   - Detailed explanations of each algorithm and its flow
   - Mathematical/statistical concepts and methods used
   - Implementation approaches and trade-offs

3. **Concept-to-code mapping table** with:
   - Mathematical/statistical concept
   - File and function location. File locations should ALWAYS be provided in relative to the codebase base directory
   - Brief description of implementation

### **Analysis Process**

#### **Phase 1: Repository Structure & Inventory**
- Create a complete file inventory organized by language
- Map the directory structure and module organization
- Identify build files, configuration, and language bindings (Cython, Rcpp, etc.)
- Locate API entry points and public interfaces
- Find example scripts or command-line interfaces

#### **Phase 2: Algorithmic Component Discovery**
- Search for mathematical/statistical keywords: `optimize`, `solve`, `matrix`, `gradient`, `likelihood`, `sample`, `distribution`, `regression`, `estimate`, `inference`, `transform`, etc.
- Identify numerical/statistical libraries in use (NumPy, SciPy, statsmodels, MASS, etc.)
- Flag functions performing mathematical operations (matrix operations, decompositions, iterations, etc.)
- Categorize algorithmic components by family (optimization, sampling, linear algebra, inference, etc.)
- Create a taxonomy of algorithm types present

#### **Phase 3: Dependency & Call Chain Analysis**
- Build static call graphs for each algorithmic function
- Trace what each function calls (using AST parsing for Python, code parsing for R/C++)
- Map data flow patterns: how data structures transform between functions
- Identify computational pipelines and processing stages
- Note inter-language calls (e.g., Python calling C extensions)

#### **Phase 4: Algorithm Deep Dive**
- For each core algorithm, extract:
  - Mathematical operations performed
  - Statistical/numerical method being implemented
  - Literature references or standard algorithm names
  - Edge cases and numerical stability considerations
  - **Cross-domain terminology**: Document alternate names the algorithm/method may be known by in different fields:
    - **Statistics**: classical statistical terminology
    - **Mathematics**: pure/applied mathematics naming
    - **Computer Science**: algorithmic/computational perspective
    - **Physics**: physical sciences terminology (e.g., statistical mechanics, quantum computing)
    - **Machine Learning/AI**: ML community conventions
    - **Data Science**: data science/analytics terminology
    - **Network Science**: graph theory and network analysis terms
    - **Signal Processing**: DSP and information theory names
    - **Operations Research**: optimization and decision science terms
    - **Bioinformatics/Computational Biology**: domain-specific naming
    
    *Example: An algorithm implementing eigendecomposition of a symmetric matrix might be called:*
    - *"Spectral decomposition" (linear algebra/mathematics)*
    - *"Principal Component Analysis" when applied to covariance matrices (statistics/data science)*
    - *"Proper Orthogonal Decomposition" (computational fluid dynamics/physics)*
    - *"Karhunen-Lo√®ve Transform" (signal processing)*
    - *"Graph Laplacian eigendecomposition" when applied to graphs (network science)*

- Recognize standard algorithms (Newton-Raphson, MCMC methods, matrix factorizations, etc.)
- Document any custom or novel implementations
- Note performance-critical sections

#### **Phase 5: Create Comprehensive Documentation**
- Generate Mermaid diagrams at multiple levels of abstraction. Verify correctness of Mermaid syntax and update diagrams if errors are found.
- Write detailed markdown documentation with clear sections
- Compile the concept-to-code mapping organized by mathematical domain
- Include code snippets for key algorithmic implementations
- Highlight extension points and debugging considerations

### **Instructions**

Please analyze the codebase following the five-phase process. For each phase, provide detailed findings. Prioritize clarity and completeness in the deliverables.
Output a final report as a Markdown document titled "core_algorithms_overview.md". If this file already exists then confirm that overwriting is ok. If not ok then ask for an alternative file name.
Once all steps are complete, ask me if I would like you to create a lightweight "quick_start_user_guide.md" cheat sheet.
